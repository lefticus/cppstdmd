# yaml-language-server: $schema=../schemas/item.schema.json
#
# Knowledge Items
# Scrolls and crystals that represent C++ knowledge.

items:
  # === Language Scrolls ===

  - id: raii_scroll
    name: RAII Scroll
    category: language_scroll
    rarity: uncommon
    description: Fundamental wisdom about resource management.
    lore: |
      "In ancient times, resources were managed by hand,
       leading to leaks and corruption. Then came RAII:
       acquire in constructor, release in destructor.
       The destructor always runs. Always.

       Wrap every resource. Trust the stack.
       Let scope be your guardian."

    sourceSection: class.dtor

    effects:
      statBoost:
        fundamentals: 2

  - id: smart_pointer_scroll
    name: Smart Pointer Scroll
    category: language_scroll
    rarity: uncommon
    description: Knowledge of automatic memory management.
    lore: |
      "Three pointers guard the realm of memory:

       unique_ptr - The Exclusive Guardian
       One owner, one pointer, zero overhead.
       When it dies, so does what it guards.

       shared_ptr - The Collective Watch
       Many may hold it, counted and tracked.
       Only when the last releases does it fall.

       weak_ptr - The Silent Observer
       Watches but does not own. Breaks the cycles
       that would trap shared_ptr in eternal life."

    sourceSection: mem.res.smartptr

    effects:
      statBoost:
        fundamentals: 1
        library: 1

  # === Pattern Crystals ===

  - id: lambda_mastery_crystal
    name: Lambda Mastery Crystal
    category: pattern_crystal
    rarity: rare
    description: Crystallized understanding of lambda expressions.
    lore: |
      "From simple captures to generic templates,
       the lambda evolved through the ages:

       C++11: Birth - [captures](params){ body }
       C++14: Generic - auto parameters
       C++17: Constexpr - compile-time lambdas
       C++20: Templates - explicit template params

       A lambda is not just syntax sugar.
       It is a function object, born of the compiler,
       living in the scope that created it."

    sourceQuest: lambda_evolution

    effects:
      statBoost:
        modernCpp: 5

  - id: crtp_crystal
    name: CRTP Crystal
    category: pattern_crystal
    rarity: rare
    description: The secret of the Curiously Recurring Template Pattern.
    lore: |
      "To know thyself at compile time:

       template<typename Derived>
       class Base {
         void interface() {
           static_cast<Derived*>(this)->impl();
         }
       };

       class Concrete : public Base<Concrete> {
         void impl() { /* ... */ }
       };

       The base knows its child. The child inherits
       the base that knows it. A curious recursion
       that enables static polymorphism."

    sourceSection: temp.param

    effects:
      statBoost:
        metaprogramming: 3

  # === Temporal Fragments ===

  - id: generic_lambda_shard
    name: Generic Lambda Shard
    category: temporal_fragment
    rarity: uncommon
    description: A fragment of C++14's generic lambda innovation.
    lore: |
      "Before C++14, every lambda was locked to specific types.
       Then came auto parameters, and lambdas became generic:

       auto print = [](auto x) { std::cout << x; };

       One lambda, infinite types. The template power
       of functor classes, with the brevity of lambdas."

    sourceEra: n4140

    effects:
      statBoost:
        modernCpp: 2

  - id: lambda_template_shard
    name: Lambda Template Shard
    category: temporal_fragment
    rarity: rare
    description: A fragment of C++20's template lambda capability.
    lore: |
      "In C++20, lambdas gained explicit template syntax:

       []<typename T>(std::vector<T>& v) {
         // T is explicitly named, not just auto
       };

       The full power of templates, in lambda form.
       Constraints, concepts, SFINAE - all available
       in these compact function objects."

    sourceEra: n4861

    effects:
      statBoost:
        modernCpp: 2
        metaprogramming: 1

  # === Undefined Realm Items ===

  - id: aliasing_scroll
    name: Scroll of Type Accessibility
    category: language_scroll
    rarity: uncommon
    description: A scroll inscribed with the rules of strict aliasing.
    lore: |
      "The strict aliasing rule guards the realm of optimization.
       Types may only access each other if they are compatible:

       - The same type (with any cv-qualification)
       - Signed and unsigned variants
       - The blessed trio: char, unsigned char, std::byte

       Through char and byte, all memory may be seen.
       Through pointer cast, chaos lies between.

       Violate these laws and the optimizer will punish you.
       Your 'clever' cast becomes invisible. Your program, undefined."

    sourceSection: basic.lval

    effects:
      statBoost:
        fundamentals: 2

  - id: undefined_mastery_crystal
    name: Crystal of Defined Boundaries
    category: pattern_crystal
    rarity: rare
    description: |
      A crystal that pulses between solid and translucent states,
      representing the boundary between defined and undefined behavior.
    lore: |
      "In the realm where no requirements exist,
       this crystal marks the edge of the abyss.

       Undefined behavior: 'no requirements'
       The compiler may do anything. Anything.
       Nasal demons. Time travel. Silent corruption.

       Erroneous behavior: 'defined, but wrong'
       The new middle ground of C++26.
       You get a value. It's meaningless. But it exists.

       From undefined to erroneous the crystal glows,
       as the standard's wisdom grows.
       The abyss recedes, one byte at a time."

    sourceQuest: undefined_realm

    effects:
      statBoost:
        fundamentals: 3
        modernCpp: 2
